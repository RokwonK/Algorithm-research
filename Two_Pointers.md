# Two_Pointer(투 포인터)
원하는 값을 얻기 위하여 두 개의 포인터(start와 end)를 사용하여 답을 얻는 테크닉

# 
## 방법
- 각각을 가르키는 포인터 2개를 가진다
- 각각의 포인터는 구간을 뜻하는 것으로 처음과 끝을 가르킨다
- 처음과 끝안의 있는 값(예를 들어 그것들의 합)이 원하는 답과 일치하는지 여부를 판단
- 일치하는지 안하는지에 따라 구간처음을 가르키는 start를 움직일지 끝을 가르키는 end를 움직일지를 판단한다

## 시간복잡도
- 부르트포스를 이용하면 O(N^2)이 나오지만  
위와 같은 투포인터를 이용하여 값을 얻을경우 O(N)까지 줄일 수 있다

## 한계
- 구간을 확인하는 기술이므로 포인터를 좌에서 우로 쓸어담듯이 이동하며 확인하는 기술이다(**슬라이딩 윈도우와 비슷한 기술임**)  
고로, 좌에서 우로 쓸어담으면서 확인하는 것이 정확한 답을 유도할 수 있는지 확실해야 함 정렬이 필요할 수도, 정렬을 해도 원하는 답을 얻지 못할 수도 있음



기본개념 코드
```cpp

//더해서 100이 되는 모든 경우의 수를 구해야함
int main(void) {

    //더해서 100이 되는 경우의 수
    int ans = 0;

    //오른차순으로 값을 받음
    for (int i = 0; i < N; i++)
        cin >> arr[i];
    
    int value = 100;

    //처음과 끝을 가르키는 포인터
    int start = 0;
    int end = 0;
    int sum = arr[0];

    //구간의 합 sum이 N보다 적으면 end를 늘려주며 sum값을 늘려줌
    //구간의 합 sum이 N보다 크다면 start를 늘려주어 구간의 sum값을 줄여줌
    while (end < N) {
        if (sum < N) {
            sum += arr[++end];
            if (sum == N)
                ans++;
        }
        else {  //sum >= N
            sum -= arr[start++];
            if (sum == N)
                ans++;
        }
        // start가 end를 넘어서 버리면 그 이후는 볼 필요도 없음
        // why? 값들은 오름차순으로 정렬되어 있고 start가 end를 넘어서는 경우는
        //      sum이 N보다 크다는 경우 이므로 뒤어 있는 원소들은 하나하나 자체가 N보다 크다는 것
        if (start > end) break;
    }

    return 0;
}
```