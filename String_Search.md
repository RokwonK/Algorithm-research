# String_search Algorithm (문자열 검색 알고리즘)

같은 문자열을 찾는 문자열 검색 알고리즘  
같은 문자열을 찾는데 부르트포스 알고리즘을 쓴다면 O(N*M)이 걸린다 (문자열(N)내에서 문자열(M)을 찾을 때)
문자열 검색을 최적화 하는 알고리즘(KMP, 보이어 무어)를 사용하면 O(N+M)에 해결 가능

## KMP 알고리즘
- 접두사와 접미사를 활용하여 검색시 공통되는 부분으로 건너뛸 수 있게 해 시간을 단축시키는 알고리즘
- 특징 중 하나로 **실패함수**를 활용

### 나오게 된 배경(내 생각)
- ABCABCABDEEE 에서 ABCABD를 찾기

- 이렇게 한칸씩 옮기면서 찾으면 시간적으로 손해
> ABCABCABDEEE  
ABCABD   
-ABCABD  
--ABCABD

- 틀린 곳에서 바로 그냥 넘어가버리면 정답을 걸러 버릴 수 있음
>ABC<span style="color:red">ABCABD</span>EEE  
ABCABD  
---------ABCABD

- 실패함수를 이용하여 아래와 같이 바로 이동하게 해줌
- D에서 틀렸을때 앞에 AB는 이미 같다는 것을 아니까 검사를 건너뛰고 그 다음 것을 바로 검사하게 해줌
>ABC<span style="color:red">ABCABD</span>EEE  
ABCABD  
----ABCABD


### 실패함수란?
- 찾을 문자열을 기준으로 접두사와 접미사 각 인덱스마다 몇개의 문자가 같은지를 저장해 놓는 배열을 만드는 것  
다시 말해, 앞에 검사한 것들은 다시 검사하지 않게 하기 위한 것임

```cpp

// 1. 자신이 몇번째 문자와 같은지를 저장과 동시에 
// 2. 접두사와 몇개나 같은지를 뜻함
int fail[str.size()];

void fail_func(string str) {
    fail[0] = 0;

    // 멘 앞에서부터 몇번째 까지의 접두사와 같았는지를 저장
    // 다음 문자를 비교할때 쓸때없이 다시 확인 할 필요 없어 용이함
    // + 자신과 똑같이 반복되어서 나오는 부분으로 돌아갈 수 있게해줌
    int j = 0;
    for (int i = 1; i < str.size(); i++) {

        // 공통인 구간의 길이를 좁혀간다 (j의 값을 업데이트 하는 구간)
        // 두개가 같아지는 구간이 없으면 결국 0이 들어감 
        while (j > 0 && str[i] != str[j]) {
            /*
                1. 그 쪽( fail[j-1]의 값을 j로 str[j]로 받으면 )으로 돌아가면 자신과 같은 문자를 
                   가진 친구를 만날 수 있다
                2. 같은 문자를 가졌다는 건 그 친구의 실패값을 기준으로 자신의 값을 정할 수 있다.
            */
            // KMP에서 가장 아름다운 코드
            j = fail[j-1];
        }

        // 같다면 j값을 전 값보다 하나 더 많다는 뜻이므로 증가시켜줌
        if(str[i] == str[j])
            fail[i] = ++j;

    }
}
```
# 

### 문자열 매칭

- 매칭할 문자열의 실패함수를 이용하여 시간복잡도를 줄일 수 있음  

**핵심개념** : *필요없는 정보는 버린다*

여기서
<img src="https://i.imgur.com/LzNjy1N.png" />



바로 여기로
<img src="https://i.imgur.com/NdOPPyB.png" />

- 문자열 매칭 알고리즘
```cpp

int fail[p.size()];

//s는 확인할 문자열, p는 찾을 문자열
int kmp(string s, string p) {

    vector<int> ans;
    int n = s.size()
    int m = p.size();

    int j = 0;

    // 확인할 문자열 만큼 반복
    for(int i=0; i<n; i++){

        // 틀린 곳에서 문자열p의 틀린부분의 실패값(접두사와 맞는 문자의 갯수/ 확인할 문자의 Index를 의미) 부터 검색함
        // 시간을 줄이는 것
        while(j > 0 && s[i] != p[j]) 
            j = fail[j-1];

        if(s[i] == p[j]){
            //찾고자 하는 문자열이 모두 매칭!
            j++;
            if(j == m){
                ans.push_back(i-m+1); //문자열 하나 찾았구, 첫번째 위치(이때의 위치는 index가 아니라 번쩨)를 저장

                // 하나 문자매칭 완료했으니 다시 문자열이 같은지 확인
                j = fail[j-1];
            }
        }

    }



}
```

